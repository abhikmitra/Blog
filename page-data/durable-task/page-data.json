{"componentChunkName":"component---src-templates-blog-post-js","path":"/durable-task/","result":{"data":{"site":{"siteMetadata":{"title":"Abhik's Blog"}},"markdownRemark":{"id":"16200fb1-2464-5a53-8706-98b3791f2a49","excerpt":"Durable Task Framework The Durable Task Framework is an orchestration framework for dot net apps. You can read more about it in their official github repo. This…","html":"<h3>Durable Task Framework</h3>\n<p>The Durable Task Framework is an orchestration framework for dot net apps. You can read more about it in their official <a href=\"https://github.com/Azure/durabletask\">github repo</a>. This <a href=\"https://channel9.msdn.com/Shows/On-NET/Building-workflows-with-the-Durable-Task-Framework\">channel 9 video</a> does a pretty good job of explaining about the framework.</p>\n<p>While I was reading through the materials , I felt the literature out their treated the system as a blackbox and I could’nt find any material on the web on how does DTF works under the hood. So I cloned DTF repo and added console logs to understand how it works. The following details apply to <a href=\"https://www.nuget.org/packages/DurableTask.Core/\">DurableTask.Core</a> version 2.0.0.6 which maps to commit id <code class=\"language-text\">0a93eba6c9692f52776dac0f3741eccad3293ef6</code> in the DTF Github repo.</p>\n<h3>Setup</h3>\n<p>My setup has 2 console apps , DTFDemoWorker and DTFClient. DTFDemoWorker houses the hubWorker and creates the resources. I have 1 Orchestration called a TestOrchestration which does 2 activities, testActivity1 and TestActivity2 both of which console logs to the console and waits for sometime to simulate some work being done.</p>\n<p>You can find the repo <a href=\"https://github.com/abhikmitra/DTFDemo\">here</a> </p>\n<p>When we create the resources DTF creates 3 Queues in the Service Bus </p>\n<ul>\n<li>&#x3C;TaskHubName>/orchestrator</li>\n<li>&#x3C;TaskHubName>/tracking</li>\n<li>&#x3C;TaskHubName>/worker\n. </li>\n</ul>\n<h3>Steps</h3>\n<p>We will see whats the process in which Orchestrator provides reliability. We will ignore the tracking Queue for now and add that later. To kepe the diagrams simple , lets assume we just have 1 Task that gets invoked.</p>\n<ol>\n<li>\n<p>We start the process with the following code from the Client.</p>\n<div class=\"gatsby-highlight\" data-language=\"c#\"><pre class=\"language-c#\"><code class=\"language-c#\">var instance = client.CreateOrchestrationInstanceAsync(typeof(TestOrchestration), &quot;InstanceId5302&quot;, &quot;Test Input&quot;).Result;</code></pre></div>\n</li>\n<li>This will send a message with event name <code class=\"language-text\">ExecutionStarted</code> message into the Orchestrator queue.There will be other details such as the orchestration name and id , that will help DTF to operate on teh correct instance of orchestration.</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"mermaid\"><pre class=\"language-mermaid\"><code class=\"language-mermaid\">sequenceDiagram\n    Client-&gt;&gt;Orchestrator: ExecutionStarted</code></pre></div>\n<ol start=\"3\">\n<li>This is received by the hub &#x26; the actual <a href=\"https://github.com/abhikmitra/DTFDemo/blob/master/Domains/TestOrchestration.cs\">TestOrchestration</a> code is invoked. As you can see in the link above , I have put in log statements and 2 log statements are invoked.</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"mermaid\"><pre class=\"language-mermaid\"><code class=\"language-mermaid\">sequenceDiagram\n    Client--&gt;&gt;Orchestrator: ExecutionStarted\n\n    Orchestrator--&gt;&gt;Hub: ExecutionStarted\n\n    Hub-&gt;&gt;TestOrchestration: Orchestration Invoked</code></pre></div>\n<ol start=\"4\">\n<li>\n<p>Assume the orchestration code is as below. The orchestration runs till <code class=\"language-text\">scheduleWithRetry</code> and prints <code class=\"language-text\">Running Orchestration</code> into the console. Since this is the first time orchestration is running <code class=\"language-text\">Is replaying</code> is set to false. </p>\n<div class=\"gatsby-highlight\" data-language=\"c#\"><pre class=\"language-c#\"><code class=\"language-c#\">Console.WriteLine(&quot;Is Replaying =&quot; + context.IsReplaying);\nConsole.WriteLine(&quot;Running Orchestration&quot;);</code></pre></div>\n</li>\n</ol>\n<p>await context.ScheduleWithRetry<bool>(typeof(TestActivity1), options, \"\");</p>\n<p>Console.WriteLine(“Orchestration Finished”);\nreturn result; </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">When the orchestration encounters an activity it puts a message into the Worker Queue and exits the orchestration. The rest of the orchestration is not executed.\n\n```mermaid\nsequenceDiagram\n    Client--&gt;&gt;Orchestrator: ExecutionStarted\n\n    Orchestrator--&gt;&gt;Hub: ExecutionStarted\n\n    Hub-&gt;&gt;TestOrchestration: Orchestration Invoked\n    Hub--&gt;&gt;Worker: TaskScheduled</code></pre></div>\n<ol start=\"5\">\n<li>\n<p>The hub is also listening to the Worker Queue and picks up the <code class=\"language-text\">TaskScheduled</code> message and invokes the TaskActivity. For now lets assume all the TaskActivity does is a console log. So the task is immediately completed. When the task is completed the hub queues TaskCompleted event in the Orchestrator queue.</p>\n<div class=\"gatsby-highlight\" data-language=\"mermaid\"><pre class=\"language-mermaid\"><code class=\"language-mermaid\">sequenceDiagram\nClient--&gt;&gt;Orchestrator: ExecutionStarted\n\nOrchestrator--&gt;&gt;Hub: ExecutionStarted\n\nHub-&gt;&gt;TestOrchestration: Orchestration Invoked\nHub--&gt;&gt;Worker: TaskScheduled\nWorker--&gt;&gt;Hub: Task Scheduled\nHub-&gt;&gt;TaskActivity: Task Invoked\nHub--&gt;&gt;Orchestrator: TaskCompleted</code></pre></div>\n</li>\n<li>The Orchestration wakes up moment the hub detects a message in the Orchestrator Queue and <em>restarts the Orchestration from the beginning</em>. So all the logs that got printed last time gets printed again. Since this is the second time orchestration is running <code class=\"language-text\">Is replaying</code> is set to <em>True</em>.</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"mermaid\"><pre class=\"language-mermaid\"><code class=\"language-mermaid\">sequenceDiagram\n   Client--&gt;&gt;Orchestrator: ExecutionStarted\n\n   Orchestrator--&gt;&gt;Hub: ExecutionStarted\n\n   Hub-&gt;&gt;TestOrchestration: Orchestration Invoked\n   Hub--&gt;&gt;Worker: TaskScheduled\n   Worker--&gt;&gt;Hub: Task Scheduled\n   Hub-&gt;&gt;TaskActivity: Task Invoked\n   Orchestrator--&gt;&gt;Hub: TaskCompleted\n   Hub-&gt;&gt;TestOrchestration: Orchestration Invoked &amp; Completed</code></pre></div>\n<ol start=\"7\">\n<li>What happens when the the Hub fails in Step #5 while it is running the taskActivity ?</li>\n<li>In a distributed system , we have to work with teh assumption that the hub can fail any time and so can the task. </li>\n<li>The hub does not remove the TaskScheduledEvent unless the TasActivity is complete. So if in case the hub goes down, the service bus message will be present in teh queue. When the hub comes back , it will start from step 5 as if nothing had happened.</li>\n<li>\n<p>What if, the Task itself throws an exception  ? </p>\n<div class=\"gatsby-highlight\" data-language=\"mermaid\"><pre class=\"language-mermaid\"><code class=\"language-mermaid\">sequenceDiagram\nClient--&gt;&gt;Orchestrator: ExecutionStarted\nOrchestrator--&gt;&gt;Hub: ExecutionStarted\nHub-&gt;&gt;TestOrchestration: Orchestration Invoked\nHub--&gt;&gt;Worker: TaskScheduled\nWorker--&gt;&gt;Hub: Task Scheduled\nHub-&gt;&gt;TaskActivity: Task Invoked\nNote right of TaskActivity: Throws Exception!\nHub--&gt;&gt;Orchestrator: TaskFailed\nOrchestrator--&gt;&gt;Hub: TaskFailed\nHub-&gt;&gt;TestOrchestration: Orchestration Invoked\nnote left of TestOrchestration: Error Handling &lt;br/&gt; Runs  till &lt;br/&gt;ScheduleWithRetry\nHub--&gt;&gt;Orchestrator: Timer Fired\nOrchestrator--&gt;&gt;Hub: Timer Fired\nHub-&gt;&gt;TestOrchestration: Orchestration Invoked\nHub--&gt;&gt;Worker: TaskScheduled\nnote left of TestOrchestration: Happy path restarts</code></pre></div>\n</li>\n<li>How does DTF remember the results of each task Activity ?</li>\n<li>DTF serializes all the events into orchestration messages (Session State) that it puts in service bus. For eg,\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 562px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/blog/static/2798b67dcb285c283fb0a0df1e938e67/6e88f/serializedState.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 90.54054054054053%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAC2UlEQVQ4y41U2XLaQBDk/38pfsAgdF+AjQAJCYG5BOZK7HKVXe5MjwA7lYdEVVO7O9rt6Znp3cb++RnbaovtdoePjw98fn7i+nH9L3t/f8f5fMbb2xteX1/R2Gw2KPICHPmjnE4xeBxgmCSoqgq73e6/7FmIcWzkeY4szbATx+FwwHq9xmKxwHK5FNbbvw4ySLWplADn3HM1BZxkGcIgRDJIdOzGXYyGQ/R7PZ3TojBCr1vPk8EA02KKoiiQpukNlERIqJGJ0zQ68DwfVseE53qwTAuBF4j58BxPAfnPsV0kyRCJlGQ8HmM0GgnQBi8vL5Ly7gvQ6lhwHRdxFAmzPjoSwBcw13YExBHAUP57F1AHpoyt+5YEtrXeo+EIT08LHI9HNFKJ5FgObMtW0JqNpT6y5Uh/GASwzXoPMyCoI3PDMDT44DGpAcdCmw7LNNFsNuuDtq2pEtgXUJbDNARAgpKl0Wqj3TIQRTHWq7VK7lZDMrQZUYwM2BjzkrLnupoi2ROU7DzPQ5ZNMJ/NJc0nGWcoyxIzWStgPplcUgq1EawjmxHJ2vd99XsCGviBNCLFRPbPBISMKK2FgC6kfgRXQJWNH2q9yKrX7Um6dYA4jgUo1LRjSY+1Y93YAN6ujXR4tVqpEfwGyI1sBpn6kpLv1szoIzMGISh9/W5fdcrL8PDwoOC/fv0UUW+/aqi68+tmhCIR1iwKYwFxNQilZF406ooWW817PdNuG1LPTK8sBf4HQ/OiMWqOHVX5SOf5jyW4Nodsr9lMpyVO55MC8bYoYDHJVaTcUOvRugndkjlFzvW9sLr7cSeAfb3HtLUY7y/1dwNM07Hqy+YNEEaUxRWQnU6ls6UwYWlYt1wI5JdOM11293Q6faXM7sznc3Vsqssr8u014bO03+91M0f6CULjnB3mY1GWM2XZ4FPFJ+xwOGqk78ZUvtt+f8BS9rPLqbDjWQLzBSrkHWWA38xfAK69acTIAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Serialized state\"\n        title=\"Serialized state\"\n        src=\"/blog/static/2798b67dcb285c283fb0a0df1e938e67/6e88f/serializedState.png\"\n        srcset=\"/blog/static/2798b67dcb285c283fb0a0df1e938e67/12f09/serializedState.png 148w,\n/blog/static/2798b67dcb285c283fb0a0df1e938e67/e4a3f/serializedState.png 295w,\n/blog/static/2798b67dcb285c283fb0a0df1e938e67/6e88f/serializedState.png 562w\"\n        sizes=\"(max-width: 562px) 100vw, 562px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span> all of this tasks is serialized into the messages.</li>\n</ol>","frontmatter":{"title":"Durable Task Framework Internals","date":"April 23, 2020","description":"Deepdive into inner workings of DTF"}}},"pageContext":{"slug":"/durable-task/","previous":{"fields":{"slug":"/hello-world/"},"frontmatter":{"title":"Hello World - Starting a new Blog Series"}},"next":null}}}