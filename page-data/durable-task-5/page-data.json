{"componentChunkName":"component---src-templates-blog-post-js","path":"/durable-task-5/","result":{"data":{"site":{"siteMetadata":{"title":"Abhik's Blog"}},"markdownRemark":{"id":"a112acc4-9302-5f27-a9a7-a534047955be","excerpt":"Durable Task Framework Series This post is part 5 of a series of posts on DTF. Durable Task Framework Internals - Part 1 (Dataflow and Reliability) Durable Task…","html":"<h3>Durable Task Framework Series</h3>\n<p>This post is <strong>part 5</strong> of a series of posts on DTF.</p>\n<ol>\n<li><a href=\"https://abhikmitra.github.io/blog/durable-task/\">Durable Task Framework Internals - Part 1 (Dataflow and Reliability)</a></li>\n<li><a href=\"https://abhikmitra.github.io/blog/durable-task-2/\">Durable Task Framework Internals - Part 2 (The curious case of Orchestrations)</a></li>\n<li><a href=\"https://abhikmitra.github.io/blog/durable-task-3/\">Durable Task Framework Internals - Part 3 (Tracker Queue, Instance History, and JumpStart)</a></li>\n<li><a href=\"https://abhikmitra.github.io/blog/durable-task-4/\">Durable Task Framework Internals - Part 4 (Terminated Orchestrations &#x26; Middlewares)</a></li>\n<li><a href=\"https://abhikmitra.github.io/blog/durable-task-5/\">Durable Task Framework Internals - Part 5 (Interesting usages of TPL in DTF)</a></li>\n<li><a href=\"https://abhikmitra.github.io/blog/durable-task-5/\">Durable Task Framework Internals - Part 6 (Orchestration Execution Flow)</a></li>\n</ol>\n<p>Do you think there is more that I should cover or something I should fix? Please raise an <a href=\"https://github.com/abhikmitra/blog/issues\">issue</a> and let me know.</p>\n<hr>\n<p>In this post, we are going to cover all the interesting Dot Net’s Task Parallel Library concepts that I found here. Some of them might not be advanced, but I have put them as I have not used these often in my regular code.</p>\n<h3>Thread Static</h3>\n<p>ThreadStatic is an attribute that marks a variable as static. You can read more about it <a href=\"https://www.c-sharpcorner.com/article/overview-of-threadstatic-attribute-in-c-sharp/\">here</a>. ThreadStatic is pretty simple to grasp. The <code class=\"language-text\">OrchestrationContext</code> has a <em>ThreadStatic</em> variable to check any time during your orchestration to see if you are on the correct thread. Now, this usually is not required, as Orchestrations should not have async operations. But if Orchestration is executing a piece of code that you have no control over and you want to check that when control comes back to your code for illegal task continuations, this would be an excellent way to check. Based on the PR <a href=\"https://github.com/Azure/durabletask/pull/171#discussion_r183195689\">here</a>, this is precisely how it is used by the Azure Durable Functions team.</p>\n<h3>Synchronization Context</h3>\n<p>Synchronization Context is a little difficult to grasp. Here are the articles you should read with to understand SynchronizationContext.</p>\n<ul>\n<li><a href=\"https://hamidmosalla.com/2018/06/24/what-is-synchronizationcontext/\">What is SynchronizationContext ?</a></li>\n<li><a href=\"https://devblogs.microsoft.com/pfxteam/await-synchronizationcontext-and-console-apps/\">SynchronizationContext and Console Apps</a></li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-csharp line-numbers\"><code class=\"language-csharp\">Console<span class=\"token punctuation\">.</span><span class=\"token function\">WriteLine</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Thread {0}\"</span><span class=\"token punctuation\">,</span> Thread<span class=\"token punctuation\">.</span>CurrentThread<span class=\"token punctuation\">.</span>ManagedThreadId<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">await</span> task1\nConsole<span class=\"token punctuation\">.</span><span class=\"token function\">WriteLine</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Thread {0}\"</span><span class=\"token punctuation\">,</span> Thread<span class=\"token punctuation\">.</span>CurrentThread<span class=\"token punctuation\">.</span>ManagedThreadId<span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<p>In the above code, there is no guarantee that pre and post-task, both threads are going to be the same. What await is going to try and do is to bring back the back to control to the same SynchronizationContext. If it can find a SynchronizationContext, it will use the thread, if the <code class=\"language-text\">SynchronizationContext.Current</code> is null, it will choose any thread of the thread pool and continue on it.\nNow there are cases where SynchronizationContext is not null, like in a WPF app or other UI facing apps. In case of console apps, the starting SynchronizationContext is  null. Durable Task Framework runs the orchestration on the same thread, irrespective of whether you are running the hub in a console app or in some other way. So to achieve this, in the <code class=\"language-text\">TaskOrchestrationExecutor</code> just before Orchestration is executed, DTF sets the SynchronizationContext and unsets it after the Orchestraton is complete.\nNow when you do an <code class=\"language-text\">await</code> inside the orchestration, it might still span a thread to do an async operation, but when the execution of the async operation is completed, it will always come back to the starting thread using the SynchronizationContext.</p>\n<h3>TaskCompletionSource</h3>\n<p>These 2 articles do a pretty good job of explaining <code class=\"language-text\">TaskCompletionSource</code>.</p>\n<ul>\n<li><a href=\"https://www.pluralsight.com/guides/task-taskcompletion-source-csharp\">Task vs. TaskCompletionSource</a></li>\n<li><a href=\"https://stackoverflow.com/questions/15316613/when-should-taskcompletionsourcet-be-used\">When should TaskCompletionSource be used ?</a></li>\n</ul>\n<p>So now, you know that TaskCompletion sources is used to convert an event-driven code to a more promise based/awaitable pattern.\nNow in DTF, we have discussed that Orchestrations get executed multiple times. Let’s assume that an orchestration as one below</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-csharp line-numbers\"><code class=\"language-csharp\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">async</span> Task<span class=\"token operator\">&lt;</span><span class=\"token keyword\">bool</span><span class=\"token operator\">></span> <span class=\"token function\">RunTask</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> task1 <span class=\"token operator\">=</span> context<span class=\"token punctuation\">.</span><span class=\"token generic-method\"><span class=\"token function\">ScheduleWithRetry</span><span class=\"token punctuation\">&lt;</span><span class=\"token keyword\">bool</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span><span class=\"token punctuation\">(</span>TestActivity1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> options<span class=\"token punctuation\">,</span> <span class=\"token string\">\"Test Input1\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">var</span> str <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token keyword\">string</span><span class=\"token punctuation\">(</span><span class=\"token string\">'x'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">500</span> <span class=\"token operator\">*</span> <span class=\"token number\">1024</span> <span class=\"token operator\">*</span> <span class=\"token number\">1024</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">await</span> Task<span class=\"token punctuation\">.</span><span class=\"token function\">Delay</span><span class=\"token punctuation\">(</span><span class=\"token number\">90000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    Console<span class=\"token punctuation\">.</span><span class=\"token function\">WriteLine</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">.</span><span class=\"token function\">Substring</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">.</span>Length <span class=\"token operator\">-</span> <span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    str <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">true</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>And from somewhere else in the code.</p>\n<div class=\"gatsby-highlight\" data-language=\"csharp\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-csharp line-numbers\"><code class=\"language-csharp\"><span class=\"token keyword\">public</span> <span class=\"token class-name\">Task</span> <span class=\"token function\">ExecuteOrchestrationAsync</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">string</span> runTimeState<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token function\">RunTask</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> Task<span class=\"token punctuation\">.</span><span class=\"token function\">FromResult</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>So, we are invoking RunTask and not waiting for it to complete. As a result, now we are stuck with 500 MB of data, which will be in memory for 90 seconds. Considering that orchestrations can run days. What would you expect for the below piece of code?</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">public async Task&lt;bool&gt; RunTask()\n{\n    var task1 = context.ScheduleWithRetry&lt;bool&gt;(typeof(TestActivity1), options, &quot;Test Input1&quot;);\n    var str = new string(&#39;x&#39;, 500 * 1024 * 1024);\n    await task1;\n    Console.WriteLine(str.Substring(str.Length - 10));\n    str = null;\n    return true;\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Tasks typically take much more than 90 seconds. And considering the orchestration would be invoked at least 2 times, we are looking at 1 GB of data per task. And if you remember Part 2, Orchestration gets executed multiple times, and it is perfectly normal for orchestration to Execute <code class=\"language-text\">await task</code> and never come back. So what happens is that <code class=\"language-text\">ScheduleWithRetry</code> gives back a TaskCompletionSource. </p>\n<p>And whenever the framework detects that </p>\n<ul>\n<li>There is no reference to TaskCompletionSource, so it cannot be set as completed.</li>\n<li>The async call itself is not awaited</li>\n</ul>\n<p>It garbage collects the memory.</p>\n<p>So hence, you will not see the memory leak that you would typically expect with async operations as the framework is smart enough to distinguish between the tasks that may complete and tasks that will never complete.\nThis is not generally a recommended pattern, as per the <a href=\"https://devblogs.microsoft.com/pfxteam/dont-forget-to-complete-your-tasks/\">experts</a>.</p>","frontmatter":{"title":"Durable Task Framework Internals - Part 5 (Interesting usages of TPL in DTF)","date":"April 27, 2020","description":"In this part, we look at some of the interesting usages of the Task Parallel Library in DTF "}}},"pageContext":{"slug":"/durable-task-5/","previous":{"fields":{"slug":"/durable-task-4/"},"frontmatter":{"title":"Durable Task Framework Internals - Part 4 (Terminated Orchestrations & Middlewares)"}},"next":{"fields":{"slug":"/durable-task-6/"},"frontmatter":{"title":"Durable Task Framework Internals - Part 6 (Orchestration Execution Flow)"}}}},"staticQueryHashes":["1246554614","919801753"]}